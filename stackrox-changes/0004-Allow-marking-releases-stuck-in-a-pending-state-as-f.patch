From 8d458afe7d4600cf04a8aa19d37d941dba932495 Mon Sep 17 00:00:00 2001
From: Malte Isberner <2822367+misberner@users.noreply.github.com>
Date: Tue, 29 Jun 2021 15:16:01 +0200
Subject: [PATCH 04/11] Allow marking releases stuck in a pending state as
 failed (#16)

Spelled without "e" to not have to reformat surrounding code causing
conflicts. Please fix the spelling when upstreaming.
---
 pkg/client/actionclient.go                    |  9 ++++
 .../internal/conditions/conditions.go         |  1 +
 pkg/reconciler/internal/fake/actionclient.go  | 14 +++++
 pkg/reconciler/reconciler.go                  | 51 +++++++++++++++++++
 4 files changed, 75 insertions(+)

diff --git a/pkg/client/actionclient.go b/pkg/client/actionclient.go
index 130219d..1fb7905 100644
--- a/pkg/client/actionclient.go
+++ b/pkg/client/actionclient.go
@@ -56,6 +56,7 @@ type ActionInterface interface {
 	History(name string, opts ...HistoryOption) ([]*release.Release, error)
 	Install(name, namespace string, chrt *chart.Chart, vals map[string]interface{}, opts ...InstallOption) (*release.Release, error)
 	Upgrade(name, namespace string, chrt *chart.Chart, vals map[string]interface{}, opts ...UpgradeOption) (*release.Release, error)
+	MarkFailed(release *release.Release, reason string) error
 	Uninstall(name string, opts ...UninstallOption) (*release.UninstallReleaseResponse, error)
 	Reconcile(rel *release.Release) error
 }
@@ -308,6 +309,14 @@ func (c *actionClient) Upgrade(name, namespace string, chrt *chart.Chart, vals m
 	return rel, nil
 }
 
+func (c *actionClient) MarkFailed(rel *release.Release, reason string) error {
+	infoCopy := *rel.Info
+	releaseCopy := *rel
+	releaseCopy.Info = &infoCopy
+	releaseCopy.SetStatus(release.StatusFailed, reason)
+	return c.conf.Releases.Update(&releaseCopy)
+}
+
 func (c *actionClient) rollback(name string, opts ...RollbackOption) error {
 	rollback := action.NewRollback(c.conf)
 	for _, o := range opts {
diff --git a/pkg/reconciler/internal/conditions/conditions.go b/pkg/reconciler/internal/conditions/conditions.go
index 55e2c65..86beb90 100644
--- a/pkg/reconciler/internal/conditions/conditions.go
+++ b/pkg/reconciler/internal/conditions/conditions.go
@@ -41,6 +41,7 @@ const (
 	ReasonUpgradeError             = status.ConditionReason("UpgradeError")
 	ReasonReconcileError           = status.ConditionReason("ReconcileError")
 	ReasonUninstallError           = status.ConditionReason("UninstallError")
+	ReasonPendingError             = status.ConditionReason("PendingError")
 )
 
 func Initialized(stat corev1.ConditionStatus, reason status.ConditionReason, message interface{}) status.Condition {
diff --git a/pkg/reconciler/internal/fake/actionclient.go b/pkg/reconciler/internal/fake/actionclient.go
index 162cdc1..bda8499 100644
--- a/pkg/reconciler/internal/fake/actionclient.go
+++ b/pkg/reconciler/internal/fake/actionclient.go
@@ -53,6 +53,7 @@ type ActionClient struct {
 	Histories  []HistoryCall
 	Installs   []InstallCall
 	Upgrades   []UpgradeCall
+	MarkFailds []MarkFailedCall
 	Uninstalls []UninstallCall
 	Reconciles []ReconcileCall
 
@@ -60,6 +61,7 @@ type ActionClient struct {
 	HandleHistory   func() ([]*release.Release, error)
 	HandleInstall   func() (*release.Release, error)
 	HandleUpgrade   func() (*release.Release, error)
+	HandleMarkFaild func() error
 	HandleUninstall func() (*release.UninstallReleaseResponse, error)
 	HandleReconcile func() error
 }
@@ -82,6 +84,7 @@ func NewActionClient() ActionClient {
 		Histories:  make([]HistoryCall, 0),
 		Installs:   make([]InstallCall, 0),
 		Upgrades:   make([]UpgradeCall, 0),
+		MarkFailds: make([]MarkFailedCall, 0),
 		Uninstalls: make([]UninstallCall, 0),
 		Reconciles: make([]ReconcileCall, 0),
 
@@ -89,6 +92,7 @@ func NewActionClient() ActionClient {
 		HandleHistory:   historyFunc(errors.New("history not implemented")),
 		HandleInstall:   relFunc(errors.New("install not implemented")),
 		HandleUpgrade:   relFunc(errors.New("upgrade not implemented")),
+		HandleMarkFaild: recFunc(errors.New("mark failed not implemented")),
 		HandleUninstall: uninstFunc(errors.New("uninstall not implemented")),
 		HandleReconcile: recFunc(errors.New("reconcile not implemented")),
 	}
@@ -122,6 +126,11 @@ type UpgradeCall struct {
 	Opts      []client.UpgradeOption
 }
 
+type MarkFailedCall struct {
+	Release *release.Release
+	Reason  string
+}
+
 type UninstallCall struct {
 	Name string
 	Opts []client.UninstallOption
@@ -151,6 +160,11 @@ func (c *ActionClient) Upgrade(name, namespace string, chrt *chart.Chart, vals m
 	return c.HandleUpgrade()
 }
 
+func (c *ActionClient) MarkFailed(rel *release.Release, reason string) error {
+	c.MarkFailds = append(c.MarkFailds, MarkFailedCall{rel, reason})
+	return c.HandleMarkFaild()
+}
+
 func (c *ActionClient) Uninstall(name string, opts ...client.UninstallOption) (*release.UninstallReleaseResponse, error) {
 	c.Uninstalls = append(c.Uninstalls, UninstallCall{name, opts})
 	return c.HandleUninstall()
diff --git a/pkg/reconciler/reconciler.go b/pkg/reconciler/reconciler.go
index 9daea10..e961763 100644
--- a/pkg/reconciler/reconciler.go
+++ b/pkg/reconciler/reconciler.go
@@ -85,6 +85,7 @@ type Reconciler struct {
 	reconcilePeriod                  time.Duration
 	waitForDeletionTimeout           time.Duration
 	maxReleaseHistory                *int
+	markFailedAfter                  time.Duration
 	skipPrimaryGVKSchemeRegistration bool
 	controllerSetupFuncs             []ControllerSetupFunc
 
@@ -380,6 +381,18 @@ func WithMaxReleaseHistory(maxHistory int) Option {
 	}
 }
 
+// WithMarkFailedAfter specifies the duration after which the reconciler will mark a release in a pending (locked)
+// state as false in order to allow rolling forward.
+func WithMarkFailedAfter(duration time.Duration) Option {
+	return func(r *Reconciler) error {
+		if duration < 0 {
+			return errors.New("auto-rollback after duration must not be negative")
+		}
+		r.markFailedAfter = duration
+		return nil
+	}
+}
+
 // WithInstallAnnotations is an Option that configures Install annotations
 // to enable custom action.Install fields to be set based on the value of
 // annotations found in the custom resource watched by this reconciler.
@@ -693,6 +706,10 @@ func (r *Reconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Re
 		)
 		return ctrl.Result{}, err
 	}
+	if state == statePending {
+		return r.handlePending(actionClient, rel, &u, log)
+	}
+
 	u.UpdateStatus(updater.EnsureCondition(conditions.Irreconcilable(corev1.ConditionFalse, "", "")))
 
 	for _, h := range r.preHooks {
@@ -769,6 +786,7 @@ const (
 	stateNeedsInstall helmReleaseState = "needs install"
 	stateNeedsUpgrade helmReleaseState = "needs upgrade"
 	stateUnchanged    helmReleaseState = "unchanged"
+	statePending      helmReleaseState = "pending"
 	stateError        helmReleaseState = "error"
 )
 
@@ -818,6 +836,10 @@ func (r *Reconciler) getReleaseState(client helmclient.ActionInterface, obj meta
 		return nil, stateNeedsInstall, nil
 	}
 
+	if currentRelease.Info != nil && currentRelease.Info.Status.IsPending() {
+		return currentRelease, statePending, nil
+	}
+
 	var opts []helmclient.UpgradeOption
 	if *r.maxReleaseHistory > 0 {
 		opts = append(opts, func(u *action.Upgrade) error {
@@ -913,6 +935,35 @@ func (r *Reconciler) doUpgrade(actionClient helmclient.ActionInterface, u *updat
 	return rel, nil
 }
 
+func (r *Reconciler) handlePending(actionClient helmclient.ActionInterface, rel *release.Release, u *updater.Updater, log logr.Logger) (ctrl.Result, error) { // nolint:unparam
+	err := r.doHandlePending(actionClient, rel, log)
+	if err == nil {
+		err = errors.New("unknown error handling pending release")
+	}
+	u.UpdateStatus(
+		updater.EnsureCondition(conditions.Irreconcilable(corev1.ConditionTrue, conditions.ReasonPendingError, err)))
+	return ctrl.Result{}, err
+}
+
+func (r *Reconciler) doHandlePending(actionClient helmclient.ActionInterface, rel *release.Release, log logr.Logger) error {
+	if r.markFailedAfter <= 0 {
+		return errors.New("release is in a pending (locked) state and cannot be modified, user intervention is required")
+	}
+	if rel.Info == nil || rel.Info.LastDeployed.IsZero() {
+		return errors.New("release is in a pending (locked) state and lacks 'last deployed' timestamp, user intervention is required")
+	}
+	if pendingSince := time.Since(rel.Info.LastDeployed.Time); pendingSince < r.markFailedAfter {
+		return fmt.Errorf("release is in a pending (locked) state and cannot currently be modified, will be marked failed to allow a roll-forward in %v", r.markFailedAfter-pendingSince)
+	}
+
+	log.Info("Marking release as failed", "releaseName", rel.Name)
+	err := actionClient.MarkFailed(rel, fmt.Sprintf("operator marked pending (locked) release as failed after state did not change for %v", r.markFailedAfter))
+	if err != nil {
+		return fmt.Errorf("failed to mark pending (locked) release as failed: %w", err)
+	}
+	return fmt.Errorf("marked release %s as failed to allow upgrade to succeed in next reconcile attempt", rel.Name)
+}
+
 func (r *Reconciler) reportOverrideEvents(obj runtime.Object) {
 	for k, v := range r.overrideValues {
 		r.eventRecorder.Eventf(obj, "Warning", "ValueOverridden",
-- 
2.48.1

